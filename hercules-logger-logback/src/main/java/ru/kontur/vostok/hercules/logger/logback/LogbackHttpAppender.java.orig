package ru.kontur.vostok.hercules.logger.logback;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.UnsynchronizedAppenderBase;
import ru.kontur.vostok.hercules.gateway.client.EventPublisher;
<<<<<<< HEAD
import ru.kontur.vostok.hercules.gateway.client.EventPublisherFactory;
=======
import ru.kontur.vostok.hercules.gateway.client.EventQueue;
>>>>>>> dd18c113cdebbab7f452d08e1b24a46cfca4da0a
import ru.kontur.vostok.hercules.logger.logback.util.LogbackToEventConverter;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ThreadFactory;

/**
 * Appender for logback logger
 *
 * @author Daniil Zhenikhov
 */
public class LogbackHttpAppender extends UnsynchronizedAppenderBase<ILoggingEvent> {
<<<<<<< HEAD
=======
    private static final String QUEUE_NAME = "main";
    private LogbackHttpConfiguration configuration;
>>>>>>> dd18c113cdebbab7f452d08e1b24a46cfca4da0a
    private EventPublisher publisher;
    private LogbackHttpConfiguration configuration;

<<<<<<< HEAD
    private Set<Thread> threads = new HashSet<>();
    private EventPublisherFactory publisherFactory = new EventPublisherFactory();
    private ThreadFactory threadFactory = r -> {
        Thread thread = new Thread(r);
        thread.setDaemon(true);

        String key = String.valueOf(thread.getId());
        thread.setName(key);
        threads.add(thread);

        return thread;
    };

=======
>>>>>>> dd18c113cdebbab7f452d08e1b24a46cfca4da0a
    @Override
    public void start() {
        checkForNull();

<<<<<<< HEAD
        publisher = publisherFactory.create(
                configuration.getStream(),
                configuration.getLoseOnOverflow(),
                threadFactory);
=======
        publisher = new EventPublisher(
                configuration.getThreads(),
                configuration.getLoseOnOverflow(),
                Collections.singletonList(new EventQueue(QUEUE_NAME,
                        configuration.getStream(),
                        configuration.getPeriodMillis(),
                        configuration.getCapacity(),
                        configuration.getBatchSize())),
                configuration.getUrl(),
                configuration.getApiKey());
>>>>>>> dd18c113cdebbab7f452d08e1b24a46cfca4da0a
        publisher.start();
        super.start();
    }

    @Override
    public void stop() {
        super.stop();
        publisher.stop(1000);
    }

    @Override
    protected void append(ILoggingEvent event) {
        publisher.publish(QUEUE_NAME, LogbackToEventConverter.createEvent(event));
    }

    public LogbackHttpConfiguration getConfiguration() {
        return configuration;
    }

    public void setConfiguration(LogbackHttpConfiguration configuration) {
        this.configuration = configuration;
    }

    private void checkForNull() {
        if (configuration.getStream() == null) {
            throw new IllegalStateException("Stream is empty");
        }

        if (configuration.getLoseOnOverflow() == null) {
            throw new IllegalStateException("LoseOnOverflow is empty");
        }

    }
}

